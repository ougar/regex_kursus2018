Introduktion til Regular Expressions
========================================================
author: Kristian & Mads
date: 5. marts 2018
autosize: true


Introduktion til Regular Expressions
========================================================
incremental: true
  * Hvad handler det om?
    - Pattern matching
    - Søg (og erstat) i tekst

  * Et "regular expression" er en streng, som man søger efter i en tekst
    - Uendelige muligheder (næsten)


Introduktion til Regular Expressions
====================================
  * Kan virke afskrækkende
  * Ligner ofte noget der er løgn
```{eval=FALSE}
    <([A-Z][A-Z0-9]*)\b[^>]*>(.*?)</\1>
  
    [\w-]@([\w-]+\.)+[\w-]+
  
    ^[a-zA-Z]{1,2}\d{1}(|[a-zA-Z0-9]{1})[\s]*(|\s+)\d{1}\w{2}$
```


Introduktion til Regular Expressions
====================================
incremental: true
> &nbsp;  
>Some people, when confronted with a problem, think  
"I know, I'll use regular expressions."  
Now they have two problems.  
> &nbsp;<br>
> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- _Jamie Zawinski_

&nbsp;
* ... det er VOLDSOMT smart"

* ... man kan starte simpelt og så udvide repertoiret

* ... man skal dog lige have nogle grundlæggende ting på plads


Introduktion til Regular Expressions
====================================
Så lad os kaste os ud i det med det samme:

* Første og mest enkle eksempel: Literal strings

> &nbsp;  
&nbsp;&nbsp;&nbsp;&nbsp;fantastisk

&nbsp;

* Tekst:

> &nbsp;  
&nbsp;&nbsp;&nbsp;&nbsp;Bordfodbold er en <span style="color:red">fantastisk</span> tilskuersport


Regex er "et kraftfuldt værktøj"
====================================
incremental:true

Et par mere avancerede og nyttige eksempler:

* Find alle ord i en tekst og læg i en liste:

``` {R}
  ord <- "Hej. Det   er.en tekst!"
  strsplit(ord," ")
```
``` {R}
  strsplit(ord,"[\\W]+",perl=TRUE)
```

Regex er "et kraftfuldt værktøj"
====================================
incremental:true

* Find alle cpr-numre i en tekst:
``` {R}
  library(stringi)
  t <- "Dette er en tekst med cprnr: 049394-1234 og der kan være flere 1234231-3421 og der er 2134 andre tal 23142342232"
```
``` {R}
  stri_extract_all_regex(t,"[\\d]{6}-[\\d]{4}")
```

Grundlæggende termer
====================

* <span style='color:blue'> regex, regexp, pattern </span>  
Mønster der beskriver en del af en tekst / det vi leder efter

* <span style='color:blue'> match </span>  
Den del af teksten, der passer (matcher) vores regex (ikke det samme som det vi leder efter!)

* <span style='color:blue'> regex engine / perl regexp / PCRE </span>  
Specifik implementering af regex, og de er desværre ikke 100% kompatible.


Regular Expressions fra toppen
==============================
incremental:true

Tekst matcher som udgangspunkt tekst:

* Regular expression (regexp):

> &nbsp;&nbsp;&nbsp;&nbsp;fodbold

&nbsp;

* Tekst:

> &nbsp;&nbsp;&nbsp;&nbsp;Bord<span style="color:red">fodbold</span> er et psykologisk spil

* Regular expressions er case sensitive  
Dvs. den matcher ikke noget i denne tekst:

> &nbsp;&nbsp;&nbsp;&nbsp;Fodbold bør spilles på et bord.

Øvelse
======
type: section
Øvelse 1

* Gå til: http://ougar.dk/R/regex_kursus2018/regex_opgaver.html

* Kig på øvelse 1, og så går vi videre her om lidt.

* Vi havde tænkt at man løste øvelserne 2 og 2.

* Man kan også løse dem alene, hvis man har mere lyst til det.


Brackets
========
type:section

[ &nbsp; &nbsp; ]


Brackets
========

Matcher en enkelt karakter fra et sæt af karakterer

```
[abc]
```

Matcher ENTEN a, b eller c.

Dvs. hele udtrykket matcher en enkelt karakter - altid kun 1

> fod<span style="color:red">b</span>old

> or<span style="color:red">a</span>nge

> En sød <span style="color:red">a</span>be


Brackets
========

Det kan så bruges i et større regexp mønster

```
gr[ea]y
```

Matcher "gr" efterfulgt af ENTEN "e" eller "a" efterfulgt af "y"

> Matcher: The color is <span style="color:red">grey</span>

> Matcher The color is <span style="color:red">gray</span>

> Matcher IKKE: The color is greay

&nbsp;

(*) Rækkefølgen inde i klammerne betyder ikke noget  
[abc] == [cab]

Brackets
========
incremental:true

Praktisk når man kun kender det man leder efter i store træk, fx når man søge efter filer.

Var mit filnavn med mellemrum, bindestreg eller underscore? Og havde jeg nu husket at skrive *.R* med stort?

```
min[-_ ]fils[-_ ]navn\.[Rr]
```
> <br><div style="font-family: monospace">
> andet-filnavn.ppt <br/>
> ligegyldigt filnavn.docx <br/>
> <span style="color:red">min fils_navn.r</span><br/>
> ubrugelig_fil.sas <br/></div>

<br/> Hov, jeg havde brugt mellemrum *og* underscore! Og endda skrevet *.R* med småt! - pinligt!

Brackets
========

Man kan bruge en bindestreg til at mathe en serie af karakterer:

```
[a-z]

[0-9]

[A-F]
```

Men klammerne matcher stadig kun en enkelt karakter i teksten!

Man kan bruge flere "ranges" og kombinerer med "literals":

```
[a-zA-ZæøåÆØÅ]

20[0-2][0-9]

```

Brackets
========

Negation: &nbsp; &nbsp; [\^]

Match enhver karakter, der IKKE er i klammerne:

```
[^0-9] - match enhver karakter, der ikke er et tal

[^ ] - match enhver karakter, der ikke er et mellemrum

[^0-9][0-9][^0-9] - match f.eks. "a1a", "!4$"
```
^ SKAL stå som det første i klammerne.

```
  [A-Z^0-9]
```
Matcher alle store bogstaver, alle tal og \^-tegnet

Øvelse 2
========
type:section

* Linket til dem der har lukket siden:  
http://ougar.dk/R/regex_kursus2018/regex_opgaver.html

* Lav øvelse 2

Character classes
=================
type:section

Character classes
=================
* En række grupper af tegn bruges rigtig tit.
* Derfor findes der en række navngivne klasser:

> &nbsp; \d
```
  Digit - Det samme som [0-9] - dvs et tal
```  
>  &nbsp; \w
```
   Word character - Det samme som  
   [A-Za-z0-9_]  
   - dvs. et tal, bogstav eller _ 
```

Character classes
=================

> &nbsp; \s
```
  white Space - Mellemrum
  Typisk samme som [ \t\r\n\f]
```  

Character classes
=================

* Forkortelserne kan bruges både i og udenfor klammer:

> &nbsp; \s\d\d\s
```
  Matcher 2 cifre mellem 2 "mellemrum"
```  

> &nbsp; [\s\d]
```
  Matcher ENTEN et ciffer eller et mellemrum
```  

Character classes
=================

Der er også defineret OMVENDTE klasser - dvs. alt der IKKE er en del af klassen

> &nbsp; \S
```
  Ikke mellemrum [^ \t\r\n\f]
```  
> &nbsp; \D
```
  Alt andet end tal [^0-9]
```  
> &nbsp; \W
```
  Alt andet end "word chars" [^0-9a-zA-Z_]
```  

Character classes
=================

Eksempel:

> &nbsp; \W\d\W
```
Et tal (\d) mellem 2 tegn der IKKE er ord-tegn (\W)
```

> En dreng på <span style="color:red;text-decoration:underline">&nbsp;&nbsp;8&nbsp;&nbsp;</span> år boede på <span style="color:red;text-decoration:underline">&nbsp;&nbsp;6.</span> sal med sin 12-årige bror og lavede E2E processer.

Øvelse
======
type:section


Repetitions / Gentagelser
=========================
type:section
```
* + ?
```

Repetitions / Gentagelser
=========================
Når man matcher et element, så kan man fortælle hvor mange af dem man vil matche.

> &nbsp;  
> &nbsp;&nbsp;&nbsp; *
```
Match det tidligere element et vilkårligt antal gange (incl. 0)
```

Repetitions / Gentagelser
=========================

> &nbsp; LO*L
```
Match L + et vilkårligt antal O'er + L
```

> Hehe <span style="color:red">LOL</span>, meget sjovt.  
> &nbsp;  
> Haha <span style="color:red">LOOOOOOL</span>, sindsygt sjovt.  
> &nbsp;  
> HA<span style="color:red">LL</span>O, det er jo ikke sjovt.


Repetitions / Gentagelser
=========================
* Virker også med serier, og matcher _serien_ ikke det fundne tegn:

> &nbsp; "[0-9]*"
```
Match " + et vilkårligt antal tal + "
```

> "Hans", <span style="color:red">"3848"</span>, "Olsen"  
> &nbsp;  
> "Klaus", <span style="color:red">"0000001"</span>, "2Nielsen"

Repetitions / Gentagelser
=========================
> &nbsp;  
> &nbsp;&nbsp;&nbsp; +
```
Match det tidligere element et vilkårligt antal gange, men MINDST 1 gang
```

Repetitions / Gentagelser
=========================

> &nbsp; [0-9]+
```
Match et tal en eller flere gange  
(tag så mange som muligt)
```
> Der er <span style="color:red">123</span> bolde  

&nbsp;

> &nbsp; LO+L

> Haha <span style="color:red">LOOOOOOL</span>, sindsygt sjovt.  
> &nbsp;  
> HALLO, det er jo ikke sjovt


Repetitions / Gentagelser
=========================
> &nbsp;  
> &nbsp;&nbsp;&nbsp; ?
```
Match det tidligere element 0 eller 1 gang (dvs. "optional")
```

Repetitions / Gentagelser
=========================

> &nbsp; regexp?

> De der <span style="color:red">regexp</span> er ret smarte...  
> Også når man kalder dem <span style="color:red">regex</span>  
> Det er dog mærkeligt at kalde dem <span style="color:red">regexp</span>ppp

&nbsp;

> &nbsp; \s[a-z]*[0-9]?\s
```
  Match et antal små bogstaver samt EVENTUELT et enkelt tal omringet af mellemrum
```
> NAVN: <span style="color:red">model2</span>  
> NAVN: M<span style="color:red">odel</span> 2
  
  
Øvelse
======
type:section

Øvelse 4

Specialkarakterer
=================
type:section


Specialkarakterer
=================

En lille gruppe af karakterer har speciel betydning. Der er "kun" 12 af dem i alt:
```
   . ? * + \ ^ $ | ( ) [ {
```

Specialkarakterer
=================
transition:none
> &nbsp; . &nbsp; (punktum)
```
 . matcher enhver karakter (*) - men kun 1! 
```

&nbsp;

> Dvs. svarer til: [ALLE_TEGN]

&nbsp;

(*) Næsten: Matcher enhver karakter bortset fra "newline"

Specialkarakterer
=================
transition:none

> &nbsp;  
> &nbsp; fod.old

&nbsp;

Matcher 
```
fodbold, fodhold, fodfold, fod old  
```
... men ikke 
```
fodold, fodbbold eller fod bold
```

Specialkarakterer
=================
transition:none

```
  .*
  
```
> Matcher et vilkårligt antal af et hvilken som helst tegn  
> &nbsp;  
> Meget vigtigt pattern. Matcher _alt_


Specialkarakterer
=================

Hvis man vil fjerne det specielle ved en specialkarakter, så skal den "escapes":

> &nbsp;  
> &nbsp;1.
```
 Matcher et 1-tal efterfuldt af en vilkårlig karakter
```

&nbsp;

> &nbsp;  
> &nbsp;1\\\\.
```
  Matcher et 1-tal efterfulgt af et punktum
```

Specialkarakterer
=================

Hvis man vil fjerne det specielle ved en specialkarakter, så skal den "escapes":

> &nbsp;  
> &nbsp; \\\\ \\\\
```
Matcher en enkelt backslash
```

> &nbsp;  
> &nbsp; \\\\&nbsp;.&nbsp;\\\\&nbsp;*
```
Matcher et punktum efterfulgt af en asterix
```

Specialkarakterer
=================

Anchors: ^ og $

> &nbsp; ^
```
  Matcher starten på en streng
```

> &nbsp; $
```
  Matcher slutningen på en streng
```

Bemærk starten/slutningen er IKKE det første/sidste tegn...  
^ og $ har "zero-length match"

Specialkarakterer
=================

> &nbsp; \^ja

&nbsp;

> <span style='color:red'>ja</span> det er rigtigt
>   
> Svaret er ja
>
> tja det ved jeg ikke



Specialkarakterer
=================

> &nbsp; \^$
```
  Matcher en tom streng
```

&nbsp;

Nu kan vi lave mere komplicerede men SMARTE mønstre

```
  ^\s*#.*
```

>  Matcher en kommentar-linie i R  
>  (Hvor hele linien er en kommentar)


Specialkarakterer
=================

Man skal huske at betydningen kan afhænge af hvor i et regexp et tegn benyttes:

> \^hej
```
  Matcher "hej"" som det første i en streng
```
&nbsp;
> [\^hej]
```
  Matcher et tegn der IKKE er h,e eller j
```
&nbsp;
> [hej\^]
```
  Matcher enten et h,e,j eller ^
```

Specialkarakterer
=================

Anchors:

```
\b
```

> Matcher en word-boundary
>
> Også et zero-length match (ligesom \^ og $)
>
> Matcher ordgrænser  
> (\W til \w eller \w til \W)

```
\bbold\b
```
> Denne fodbold er en smuk <span style='color:red'>bold</span>

Specialkarakterer
=================

```
  \b[0-9]+\b
```

> Matcher et tal af vilkårlig længde

&nbsp;

```
  \W[0-9]*\W
```

> Næsten det samme, men matchet er forskelligt

Alternation
===========
```
  | (eller)
```
> Match det ene udtryk eller det andet
>
> [ab] matcher enten a eller b
>
> | er det samme, bare på udtryk

Alternation
===========
```
  kat|hund
  
```
> En <span style='color:red'>kat</span> og en <span style='color:red'>hund</span> kan tilsammen udgøre en <span style='color:red'>kat</span>astrofe

&nbsp;

Man kan have lige så mange man har lyst til:
```
  kat|hund|fisk|giraf
  
```
> <span style='color:red'>kat</span>te og <span style='color:red'>hund</span>e er nemmere at passe end <span style='color:red'>giraf</span>fer


Alternation
===========
| har laveste "operator precedence" - dvs den tager alt med:
```
  \bkat|hund\b
  
```
> En hankat og en hun<span style='color:red'>hund</span> kan ende i et hundeslagsmål og en <span style='color:red'>kat</span>tepine 


Øvelse
======

Øvelse 5

Hvornår skal man IKKE bruge reg-exp
===================================



Test
====

#The Regex Engine Always Returns the Leftmost Match

https://www.regular-expressions.info/tutorial.html

Alternation har LAVESTE precedence

They have the following advantages:

They are concise. It generally takes a lot more code to parse a specific regular language using a specific algorithm that you have come up with than with a regexp.
They are quick to use. It generally takes a lot more time to write a parser for a specific regular language using a specific algorithm that you have come up with than with a regexp.
They are easy. Once you learn the set of special characters and their meanings, it is easy to compose a regexp (although a little harder to read them). Regexps are languages themselves - a useful trait because our species has evolved to be very good at language.
They are fast. Once compiled, they can match a string length N in O(N) time.
They are flexible. They can match any regular language and a lot of our data is expressed as a regular language.
They are ubiquitous. Most programming languages have basic regexp support - either through external libraries or embedded into the language itself. There is also not too much variation between the regexp languages themselves.


I'm fond of saying that regular expressions are neither "regular" nor "expressive"
